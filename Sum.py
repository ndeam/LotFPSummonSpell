#!/usr/bin/python3

import random

# Magic-User Level, would like to have as a drop-down box on the web-app from 1-20
Magic_user_level = input("What is the level of the magic-user from 1 to 20?")

# List of magic-user saves against magic, from 1st to 20th level
Magic_user_saves = ["level 0", 14, 14, 14, 14, 14, 12, 12, 12, 12, 12, 8, 8, 8, 8, 8, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4]

#Number of HD that the monstar has, would like to have as a drop-down box on the web-app from 0-100
HD_for_summon = input("What is the HD of the creature you'd like to summon from 0 to up to twice your level (this may be modified by thaumaturgic circles and sacrifices?")

#Number of thaumaturgic circles or HD of sacrifices made to improve the range and domination roll, do I need escape characters for parentheses in strings?
Circles_sacrifices = input("What levels of thaumaturgic circles or sacrifices have you performed (500sp per 1 bonus, 2HD per 1 bonus, or 1HD of same species per 1 bonus)?")

# Variable for debugging
Most_recent_number = 0

# 0 for fail initial saving throw, 1 for pass
Pass_or_fail = 0

# this will be incremented hopefully by the determine_powers function
Number_of_powers = 0

# 0 for creature wins domination, 1 for magic-user wins domination
Dominate_or_fail = 0

# the margin of victory or defeat in the domination contest
Margin = 0

# Needs lists within dictionaries for selection of monster types
#Monster_type = {1:["blob", 2, 3, 4, 5, 6], 2:[1, 2, 3, 4, 5, 6], 3:[1, 2, 3, 4, 5, 6], 4:[1, 2, 3, 4, 5, 6], 5:[1, 2, 3, 4, 5, 6], 6:[1, 2, 3, 4, 5, 6]}

#Needs dictionaries within Dictionaries to determine which is picked
#Appendages = {1:[1, 2, 3, 4, 5, 6], 2:[1, 2, 3, 4, 5, 6], 3:[1, 2, 3, 4, 5, 6], 4:[1, 2, 3, 4, 5, 6], 5:[1, 2, 3, 4, 5, 6], 6:[1, 2, 3, 4, 5, 6]}

#Edge cases: rolling same power twice? 
#Powers = {1:"String", 2: "string", 3: "string", 4: "string", 5: "string", 6: "string", 7: "string", 8: "string", 9: "string", 10: "string", 11: "string", 12: "string", 13: "string", 14: "string", 15: "string", 16: "string", 17: "string", 18: "string", 19: "string", 20: "string", 21: "string", 22: "string", 23: "string", 24: "string", 25: "string", 26: "string", 27: "string", 28: "string", 29: "string", 30: "string", 31: "string", 32: "string", 33: "string", 34: "string", 35: "string", 36: "string", 37: "string", 38: "string", 39: "string", 40: "string", 41: "string", 42: "string", 43: "string", 44: "string", 45: "string", 46: "string", 47: "string", 48: "string", 49: "string", 50: "string", 51: "string", 52: "string", 53: "string", 54: "string", 55: "string", 56: "string", 57: "string", 58: "string", 59: "string", 60: "string", 61: "string", 62: "string", 63: "string", 64: "string", 65: "string", 66: "string", 67: "string", 68: "string", 69: "string", 70: "string", 71: "string", 72: "string", 73: "string", 74: "string", 75: "string", 76: "string", 77: "string", 78: "string", 79: "string", 80: "string", 81: "string", 82: "string", 83: "string", 84: "string", 85: "string", 86: "string", 87: "string", 88: "string", 89: "string", 90: "string", 91: "string", 92: "string", 93: "string", 94: "string", 95: "string", 96: "string", 97: "string", 98: "string", 99: "string", 100: "string"}

def die_roller(Sides_number):
    '''Rolls a die with sides equal to Sides_number'''
    global Most_recent_number
    Most_recent_number = random.randint(1, Sides_number)
    return Most_recent_number;
    print("for debugging purposes, the most recent number generated by die_roller is " + str(Most_recent_number))

#tests saving throw on a d20 according to Magic_user_level versus Magic_user_saves at the proper index, and outputs the response while changing Pass_or_fail to 1 if successful


def saving_throw(Magic_user_level, Magic_user_saves):
    Save = die_roller(20)
    Target = Magic_user_saves[int(Magic_user_level)]
    global Pass_or_fail
    if Save >= Target:
        print("Your save of " + str(Save) + " was equal to or greater than your target saving throw of " + str(Target))
        Pass_or_fail = 1
    else:
        print("Your save of " + str(Save) + " was not equal to or greater than your target saving throw of " + str(Target))
        Pass_or_fail = 0
    print("Pass_or_fail is currently " + str(Pass_or_fail))

# def base_number_tester():
#     if HD_for_summon == 0:
#         die_roller(2)
#     elif 1 <= HD_for_summon <= 2:
#         die_roller(4)
#     elif HD_for_summon < 2:
#         die_roller(6)
#     else:
#         print("broke at base_number_tester()")

# def determine_type():
#     if Pass_or_fail == 1:
#         Determine_type_die = die_roller(12)
#     else:
#         Determine_type_die = die_roller(20)
#     print("The Determine_type_die is " + str(Determine_type_die))
#     Monster = Monster_type[Determine_type_die]

# def determine_appendages():
#     Base_number = base_number_tester()
    
# def determine_powers():
#     Base_number = base_number_tester()
#     global Number_of_powers
#     Number_of_powers += 1
    
# def determine(Dictionary, HD_for_summon):
#     Base_number = base_number_tester()

# #Compares two values, modified by Magic_user_level, HD_for_summon, Circles_sacrifices, number of powers, and 
# def domination_roll():
#     global Dominate_or_fail
#     global Margin
#     Magic_user_domination = die_roller(20) + Magic_user_level + Circles_sacrifices
#     Summoned_creature_domination = die_roller(20) + HD_for_summon + Number_of_powers
#     if Magic_user_domination > Summoned_creature_domination:
#         print("Your domination roll of of " + str(Magic_user_domination) + " was greater than the summoned creature's domination roll of " + str(Summoned_creature_domination))
#         Dominate_or_fail = 1
#     elif Magic_user_domination < Summoned_creature_domination:
#         print("Your domination roll of of " + str(Magic_user_domination) + " was not greater than the summoned creature's domination roll of " + str(Summoned_creature_domination))
#         Dominate_or_fail = 0
#     else
#         print("Your domination roll of of " + str(Magic_user_domination) + " was tied with the the summoned creature's domination roll of " + str(Summoned_creature_domination)) + " and you must continue fighting for domination"
#         if #tied contest continues here
#     Margin = abs(Magic_user_domination - Summoned_creature_domination)
    
# def margin_of_domination():
#print(str(Most_recent_number))
die_roller(Sides_number = 12)
print(Most_recent_number)
saving_throw(Magic_user_level, Magic_user_saves)
print(Pass_or_fail)

    
